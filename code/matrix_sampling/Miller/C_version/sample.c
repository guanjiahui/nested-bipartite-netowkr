#include "common.h"
#include "sample_recursion.c"

// Uniformly sample a subset of size k from n elements
void sample_subset(int* x, int n, int k) {
    // initialize x to all zeros
    for (int i = 0; i<n; i++) x[i] = 0;
    
    // sample without replacement
    for (int i = 0; i<k; i++) {
        mpz_set_ui(max_number, n-i);
        mpz_urandomm(uniform_number, random_state, max_number);
        int v = mpz_get_ui(uniform_number);
        int j = 0;
        while (v>=0) {
            if (x[j]==0) v -= 1;
            j += 1;
        }
        x[j-1] = 1;
    }
}

void sample_matrix_entries(int** matrix, data_t* v, int matrix_type) {
    int m = v->m;
    int n = v->n;
    int L = v->L;
    
    // make copies of q and c
    int* u; allocate_vector_copy(int,u,v->q,n);
    int* d; allocate_vector_copy(int,d,v->c,L);
    // allocate subset indicator vector
    int* x; allocate_vector(int,x,n);
    
    if (matrix_type==0) { // binary matrix
        for (int j = 1; j<m+1; j++) {
            for (int k = 1; k<L-1; k++) {
                int r_k = d[k]-d[k+1];
                sample_subset(x, r_k, v->S[j][k]);
                int i = 0;
                int s = 0;
                while (s < r_k) {
                    if (u[i]==k) {
                        matrix[v->permutation[j-1]][i] = x[s];
                        u[i] -= x[s];
                        s += 1;
                    }
                    i += 1;
                }
                d[k] -= v->S[j][k];
            }
        }
    } else { // nonnegative integer matrix
        for (int j = 1; j<m+1; j++) {
            for (int k = L-2; k>0; k--) {
                int r_k = d[k]-d[k+1];
                sample_subset(x, r_k + v->S[j][k+1], v->S[j][k]);
                int i = 0;
                int s = 0;
                while (s < r_k + v->S[j][k+1]) {
                    if (u[i]==k) {
                        matrix[v->permutation[j-1]][i] += x[s];
                        u[i] -= x[s];
                        s += 1;
                    }
                    i += 1;
                }
            }
            for (int k = 1; k<L-1; k++) d[k] -= v->S[j][k];
        }
    }
    free(u);
    free(d);
    free(x);
}

void validate_matrix(int** matrix, data_t* v) {
    int m = v->m;
    int n = v->n;
    // check row and column sums
    for (int i = 0; i<m; i++) {
        int s = 0;
        for (int j = 0; j<n; j++) s += matrix[v->permutation[i]][j];
        assert(s==v->p[i+1], "Internal error: Sample has incorrect margins.");
    }
    for (int j = 0; j<n; j++) {
        int s = 0;
        for (int i = 0; i<m; i++) s += matrix[i][j];
        assert(s==v->q[j], "Internal error: Sample has incorrect margins.");
    }
}


void sample(int** matrix, data_t* v, int matrix_type) {
    int m = v->m;
    int n = v->n;
    int L = v->L;
    // reset matrix to all zeros
    for (int i = 0; i<m; i++) {
        for (int j = 0; j<n; j++) matrix[i][j] = 0;
    }
    // reset S and results to all zeros
    for (int j = 0; j<m+1; j++) {
        for (int k = 0; k<L; k++) {
            v->S[j][k] = 0;
            mpz_set_ui(v->results[j][k], 0);
        }
    }
    
    // get the total number of matrices
    bigint* number = hash_table_get(v->table,v->c);
    assert(number!=NULL, "Unknown number of matrices. Input file and table file may be incompatible.");

    if (matrix_type==0) {
        sample_recursion_binary(number,v->p,v->c,v->S,1,1,0,v->p[2],v->c[1],v);
    } else {
        int total = 0;
        for (int i = 1; i<=m; i++) total += v->p[i];
        sample_recursion_natural(number,v->p,v->c,v->S,1,L-2,0,total,total,v);
    }
    sample_matrix_entries(matrix,v,matrix_type);
    
    // print_matrix("%d ",S,m+1,L);
    // print_matrix("%d ",matrix,m,n);
#ifdef ERROR_CHECKING
    validate_matrix(matrix,v);
#endif
}

#ifndef MAIN
int main(int argc, char** argv) {
    if ((argc>6)||(argc<5)) {
        fprintf(stderr,"\nERROR: Incorrect usage. Aborting...\n\n");
        fprintf(stderr,"\nExample usage:\n\n");
        fprintf(stderr,"> %s input.dat table.bin output.dat 1000 0\n\n",argv[0]);
        fprintf(stderr,"  1st argument = file containing matrix size and margins\n");
        fprintf(stderr,"  2nd argument = file containing binary data generated by count.exe\n");
        fprintf(stderr,"  3rd argument = filename to use for output data\n");
        fprintf(stderr,"  4th argument = number of samples to draw\n");
        fprintf(stderr,"  5th argument = 0: normal output (default)\n");
        fprintf(stderr,"                 1: suppress all output to stdout\n");
        fprintf(stderr,"\n\n");
        exit(1);
    }
    if (argc==6) sscanf(argv[5],"%i",&quiet_mode);
    else quiet_mode = 0; // default is normal output (quiet mode off)
    
    char* input_filename = argv[1];
    char* table_filename = argv[2];
    char* output_filename = argv[3];
    int n_samples;
    sscanf(argv[4], "%i", &n_samples);
    
    // Read p (row sums), q (column sums), and matrix_type from input file
    int m,n,matrix_type;
    FILE* file = fopen(input_filename, "r");
    fscanf(file,"%i %i %i",&m,&n,&matrix_type);
    int* p; allocate_vector(int,p,m);
    int* q; allocate_vector(int,q,n);
    for (int i = 0; i<m; i++) fscanf(file,"%i",&p[i]);
    for (int i = 0; i<n; i++) fscanf(file,"%i",&q[i]);
    fclose(file);
    
    // Echo what we read in
    print("\n");
    print("Input file: %s\n",input_filename);
    print("Table file: %s\n",table_filename);
    print("Output file: %s\n",output_filename);
    print("Number of samples to draw: %d\n",n_samples);
    if (matrix_type==0) { print("Binary matrices\n"); }
    else if (matrix_type==1)  { print("Nonnegative integer matrices\n"); }
    else error("Please use a matrix type of either 0 (binary) or 1 (nonnegative integer).");
    print("m = %d\n",m);
    print("n = %d\n",n);
    print("p = "); if (!quiet_mode) print_vector("%d ",p,m);
    print("q = "); if (!quiet_mode) print_vector("%d ",q,n);
    print("====================================\n");
    
    // Initialize counting variables
    data_t* v = initialize_variables(p,q,m,n,table_filename);
    
    // Allocate memory for the matrix
    int** matrix; allocate_matrix(int,matrix,m,n);
    
    // open the output file
    // FILE* file;
    file = fopen(output_filename, "w");
    
    print("Sampling...\n");
    
    // Start the clock (to time how long it takes to run)
    clock_t start_time = clock();
    clock_t last_time = clock();
    clock_t running_time = 0;
            
    
    for (int i = 0; i<n_samples; i++) {
        
        // draw a sample matrix
        sample(matrix,v,matrix_type);
        
        running_time += clock()-last_time;
        
        // write matrix to file
        for (int i = 0; i<m; i++) {
            for (int j = 0; j<n; j++) fprintf(file,"%d ",matrix[i][j]);
            fprintf(file,"\n");
        }
        fprintf(file,"\n");
        
        last_time = clock();
    }
    // Stop the clock
    clock_t stop_time = clock();
    double total_time = ((double)(stop_time-start_time))/CLOCKS_PER_SEC;
    double sampling_time = ((double)running_time)/CLOCKS_PER_SEC;
    
    // close the output file
    fclose(file);
    
    // Print results
    print("\n");
    print("Total CPU time (including writing to disk) = %f seconds\n",total_time);
    print("CPU time used for sampling = %f seconds\n",sampling_time);
    print("CPU time per sample = %f seconds\n",sampling_time/n_samples);
    
    return 0;
}
#endif // MAIN











